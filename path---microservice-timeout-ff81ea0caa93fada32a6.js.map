{"version":3,"sources":["webpack:///path---microservice-timeout-ff81ea0caa93fada32a6.js","webpack:///./.cache/json/microservice-timeout.json"],"names":["webpackJsonp","523","module","exports","data","site","siteMetadata","title","author","markdownRemark","id","html","frontmatter","date","authorProfileLink","pathContext","slug","previous","fields","next"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,MAAQC,cAAgBC,MAAA,eAAAC,OAAA,iBAAgDC,gBAAmBC,GAAA,kIAAAC,KAAA,ssHAA8kHC,aAAqSL,MAAA,mCAAAM,KAAA,kBAAAL,OAAA,kBAAAM,kBAAA,QAA0HC,aAAgBC,KAAA,yBAAAC,UAA4CC,QAAUF,KAAA,oBAA0BJ,aAAgBL,MAAA,oBAA2BY,MAASD,QAAUF,KAAA,4BAAkCJ,aAAgBL,MAAA","file":"path---microservice-timeout-ff81ea0caa93fada32a6.js","sourcesContent":["webpackJsonp([135408179725099],{\n\n/***/ 523:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"For Enablers\",\"author\":\"Kyle Mathews\"}},\"markdownRemark\":{\"id\":\"/home/travis/build/forenablers/forenablers.github.io/src/pages/microservice-timeout/index.md absPath of file >>> MarkdownRemark\",\"html\":\"<p> The timeout pattern is perhaps the most basic way to reveal performance issues and satisfy the SLA. Even though the request did not succeed, the client gets the response within defined SLA time span and the request can be retried. It sounds easy to implement as well. Simply set the timeout in the service client, i.e. RestClient, HttpWebRequest, HttpClient. Once the timeout exceeded, the request is aborted. Wait, but is it really so simple?</p>\\n<p>Here is the excerpt from Kibana logs of the real-world production microservice. An attempt to create parking action has timed out and the caller received an error response with 500 http status code. Then the caller retried and received the error again, this time the response with 409 http status code, saying that the item already exists.</p>\\n<p><img src=\\\"./images/kibana.png\\\" alt=\\\"Kibana logs\\\"></p>\\n<p>The following diagram illustrates the high-level process:</p>\\n<p><img src=\\\"./images/uml.overview.png\\\" alt=\\\"UML overview\\\"></p>\\n<p>And this is a piece of code in API Gateway causing the problem:</p>\\n<pre><code class=\\\"language-csharp\\\">_hhtpClient.Timeout = TimeSpan.FromMilliseconds(timeout);\\nvar response = await _httpClient.SendAsync(request);\\n</code></pre>\\n<p>Even though the request timed out, the parking action has still been created. Look what happened. The API Gateway aborted the request to Parking service once timeout exceeded, but it did not cancel it. At that moment the Parking service was waiting for the database operation to complete. You are totally right if you thought of what is known as Compensating Transaction pattern. And to make it right, we have to inform the Parking service that the operation was cancelled and we should stop processing and rollback all the actions performed (if any). And here the CancellationToken comes into play.</p>\\n<p>This is what you would change at the API Gateway:</p>\\n<pre><code class=\\\"language-csharp\\\">var tokenSource = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);\\ntokenSource.CancelAfter(timeout);\\nvar response = await _httpClient.SendAsync(request, tokenSource.Token);\\n</code></pre>\\n<p>And the changes on the Parking service. First we modify controller to accept the cancellation token:</p>\\n<pre><code class=\\\"language-csharp\\\"> public async Task&#x3C;IHttpActionResult> CreateParkingright(CreateParkingrightRequest request, CancellationToken cancellationToken)\\n{\\n    cancellationToken.ThrowIfCancellationRequested();\\n    var parkingright = _parkingrightConverter.ToParkingrightEntity(request);\\n    var parkingrightId = await _parkingrightRepository.Insert(parkingright, cancellationToken);\\n    ...\\n}\\n</code></pre>\\n<p>Finally, the repository is adjusted as following:</p>\\n<pre><code class=\\\"language-csharp\\\">public async Task&#x3C;T> Insert&#x3C;T>(IModel model, object param, CancellationToken cancellationToken)\\n{\\n    T result;\\n    using (var connection = CreateSqlConnection())\\n    {\\n        using (var transaction = connection.BeginTransaction())\\n        {\\n            //NOTE: we can not use DapperExtensions here as they do not support cancellation tokens\\n            var sql = _sqlGenerator.GetInsertCommandText(model);\\n            var command = new CommandDefinition(sql, param, transaction, cancellationToken);\\n            result = await connection.ExecuteScalarAsync&#x3C;T>(command);\\n            if(!cancellationToken.IsCancellationRequested)\\n                transaction.Commit();\\n        }\\n    }\\n    return result;\\n}\\n</code></pre>\\n<p>Now, whenever the timeout exceeded, the request is cancelled, propagating the cancellation from API Gateway to the Parking service, so that it cancels the activity as well. This reduces the number of false-positive errors and provide consistent results</p>\",\"frontmatter\":{\"title\":\"Microservices: Handling timeouts\",\"date\":\"August 01, 2018\",\"author\":\"Borys Generalov\",\"authorProfileLink\":null}}},\"pathContext\":{\"slug\":\"/microservice-timeout/\",\"previous\":{\"fields\":{\"slug\":\"/hackatrain2018/\"},\"frontmatter\":{\"title\":\"Hackatrain 2018\"}},\"next\":{\"fields\":{\"slug\":\"/facebook-hackercup2018/\"},\"frontmatter\":{\"title\":\"Facebook Hackercup. 5 tips\"}}}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---microservice-timeout-ff81ea0caa93fada32a6.js","module.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"For Enablers\",\"author\":\"Kyle Mathews\"}},\"markdownRemark\":{\"id\":\"/home/travis/build/forenablers/forenablers.github.io/src/pages/microservice-timeout/index.md absPath of file >>> MarkdownRemark\",\"html\":\"<p> The timeout pattern is perhaps the most basic way to reveal performance issues and satisfy the SLA. Even though the request did not succeed, the client gets the response within defined SLA time span and the request can be retried. It sounds easy to implement as well. Simply set the timeout in the service client, i.e. RestClient, HttpWebRequest, HttpClient. Once the timeout exceeded, the request is aborted. Wait, but is it really so simple?</p>\\n<p>Here is the excerpt from Kibana logs of the real-world production microservice. An attempt to create parking action has timed out and the caller received an error response with 500 http status code. Then the caller retried and received the error again, this time the response with 409 http status code, saying that the item already exists.</p>\\n<p><img src=\\\"./images/kibana.png\\\" alt=\\\"Kibana logs\\\"></p>\\n<p>The following diagram illustrates the high-level process:</p>\\n<p><img src=\\\"./images/uml.overview.png\\\" alt=\\\"UML overview\\\"></p>\\n<p>And this is a piece of code in API Gateway causing the problem:</p>\\n<pre><code class=\\\"language-csharp\\\">_hhtpClient.Timeout = TimeSpan.FromMilliseconds(timeout);\\nvar response = await _httpClient.SendAsync(request);\\n</code></pre>\\n<p>Even though the request timed out, the parking action has still been created. Look what happened. The API Gateway aborted the request to Parking service once timeout exceeded, but it did not cancel it. At that moment the Parking service was waiting for the database operation to complete. You are totally right if you thought of what is known as Compensating Transaction pattern. And to make it right, we have to inform the Parking service that the operation was cancelled and we should stop processing and rollback all the actions performed (if any). And here the CancellationToken comes into play.</p>\\n<p>This is what you would change at the API Gateway:</p>\\n<pre><code class=\\\"language-csharp\\\">var tokenSource = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);\\ntokenSource.CancelAfter(timeout);\\nvar response = await _httpClient.SendAsync(request, tokenSource.Token);\\n</code></pre>\\n<p>And the changes on the Parking service. First we modify controller to accept the cancellation token:</p>\\n<pre><code class=\\\"language-csharp\\\"> public async Task&#x3C;IHttpActionResult> CreateParkingright(CreateParkingrightRequest request, CancellationToken cancellationToken)\\n{\\n    cancellationToken.ThrowIfCancellationRequested();\\n    var parkingright = _parkingrightConverter.ToParkingrightEntity(request);\\n    var parkingrightId = await _parkingrightRepository.Insert(parkingright, cancellationToken);\\n    ...\\n}\\n</code></pre>\\n<p>Finally, the repository is adjusted as following:</p>\\n<pre><code class=\\\"language-csharp\\\">public async Task&#x3C;T> Insert&#x3C;T>(IModel model, object param, CancellationToken cancellationToken)\\n{\\n    T result;\\n    using (var connection = CreateSqlConnection())\\n    {\\n        using (var transaction = connection.BeginTransaction())\\n        {\\n            //NOTE: we can not use DapperExtensions here as they do not support cancellation tokens\\n            var sql = _sqlGenerator.GetInsertCommandText(model);\\n            var command = new CommandDefinition(sql, param, transaction, cancellationToken);\\n            result = await connection.ExecuteScalarAsync&#x3C;T>(command);\\n            if(!cancellationToken.IsCancellationRequested)\\n                transaction.Commit();\\n        }\\n    }\\n    return result;\\n}\\n</code></pre>\\n<p>Now, whenever the timeout exceeded, the request is cancelled, propagating the cancellation from API Gateway to the Parking service, so that it cancels the activity as well. This reduces the number of false-positive errors and provide consistent results</p>\",\"frontmatter\":{\"title\":\"Microservices: Handling timeouts\",\"date\":\"August 01, 2018\",\"author\":\"Borys Generalov\",\"authorProfileLink\":null}}},\"pathContext\":{\"slug\":\"/microservice-timeout/\",\"previous\":{\"fields\":{\"slug\":\"/hackatrain2018/\"},\"frontmatter\":{\"title\":\"Hackatrain 2018\"}},\"next\":{\"fields\":{\"slug\":\"/facebook-hackercup2018/\"},\"frontmatter\":{\"title\":\"Facebook Hackercup. 5 tips\"}}}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/microservice-timeout.json\n// module id = 523\n// module chunks = 135408179725099"],"sourceRoot":""}